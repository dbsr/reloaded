// Generated by CoffeeScript 1.6.3
/* vimfox_standalone.js ~ initiates websocket / reload script*/

var namespace,
  __slice = [].slice;

namespace = function(target, name, block) {
  var item, top, _i, _len, _ref, _ref1;
  if (arguments.length < 3) {
    _ref = [(typeof exports !== 'undefined' ? exports : window)].concat(__slice.call(arguments)), target = _ref[0], name = _ref[1], block = _ref[2];
  }
  top = target;
  _ref1 = name.split('.');
  for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
    item = _ref1[_i];
    target = target[item] || (target[item] = {});
  }
  return block(target, top);
};

window.onload = function() {
  return vimfox.init();
};

namespace('vimfox', function(exports) {
  vimfox.globals = {
    RELOAD_PAGE: 0,
    RELOAD_FILE: 1,
    host: null
  };
  vimfox.files = {};
  vimfox.init = function() {
    var element, fpath, s, _i, _len, _ref;
    vimfox.status = new vimfox.Status();
    vimfox.globals.host = document.getElementById('vimfox-script').getAttribute('src').replace(/\/vimfox\/vimfox_standalone.js/, '');
    _ref = document.getElementsByTagName('*');
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      element = _ref[_i];
      fpath = element.getAttribute('data-vimfox-path');
      if (fpath != null) {
        vimfox.files[fpath] = element;
      }
    }
    if (typeof io === "undefined" || io === null) {
      s = document.createElement('script');
      s.type = 'text/javascript';
      s.onload = function() {
        return vimfox.setupSockets();
      };
      s.src = "" + vimfox.globals.host + "/vimfox/socket.io.min.js";
      return document.body.appendChild(s);
    } else {
      return vimfox.setupSockets();
    }
  };
  vimfox.setupSockets = function() {
    var socket;
    console.log("'vimfox_standalone.coffee' :: 'window.onload' => 1");
    socket = io.connect("" + vimfox.globals.host + "/ws");
    socket.on('connect', function() {
      return vimfox.status.update(0, 'OK!');
    });
    socket.on('error', function(e) {
      vimfox.status.update(2, e);
      return console.error(e);
    });
    socket.on('disconnect', function() {
      vimfox.status.update(1, 'disconnected');
      return console.debug("socket disconnected");
    });
    socket.emit('watch_files', Object.keys(vimfox.files));
    return socket.on('reload', function(fname) {
      var f;
      f = vimfox.files[fname];
      if (f != null) {
        console.log(f.tagName);
        if (f.tagName === 'LINK') {
          return f.href = f.href.replace(/\?[0-9]+$/, "") + ("?" + (+(new Date)));
        } else {
          return location.reload();
        }
      }
    });
  };
  return vimfox.Status = (function() {
    function Status() {
      var d;
      d = document.createElement('div');
      d.id = "vimfox_status";
      document.body.appendChild(d);
      this.me = document.getElementById('vimfox_status');
      this.update(1);
    }

    Status.prototype.update = function(status_code, tooltip) {
      var k, status_color, v, _ref;
      if (status_code == null) {
        status_code = 0;
      }
      if (tooltip == null) {
        tooltip = "";
      }
      status_color = ['green', 'orange', 'red'][status_code];
      _ref = {
        position: 'absolute',
        height: '10px',
        width: '10px',
        margin: '10px',
        top: '0',
        right: '0',
        backgroundColor: status_color
      };
      for (k in _ref) {
        v = _ref[k];
        this.me.style[k] = v;
      }
      return this.me.title = tooltip;
    };

    Status.prototype.kill_me = function() {
      return document.body.removeChild(this.me);
    };

    return Status;

  })();
});
